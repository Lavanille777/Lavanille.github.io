---
layout: post
title: OC中的@property及属性修饰符
category: Objective-C
---

## 什么是@property

+ @符号是OC相对C语言关键字的扩展，而property关键字，用于声明属性
+ 使用@property声明的属性，系统会为它们自动生成点符号调用的setter和getter方法

## 什么是属性修饰符

属性修饰符跟在property之后,写在小括号内，用逗号分隔开，属性修饰符会影响所声明属性的线程安全，是否可写，及内存管理方面的特性。

## 各种属性修饰符的含义及用法

MRC与ARC环境下的属性修饰符有所不同，尽管在ARC下，MRC的修饰符仍然可以使用。

这里分开说明。

### MRC

+ retain : 中文意为持有，也可以叫强引用，我们将某个对象赋给这种属性的引用时，该对象的引用计数器将会加1，在MRC环境下，当强引用不再指向对象时，需要向对象发送release消息使引用计数器减1，当引用计数器为0时，对象将会释放。

+ assign : 中文意为赋值，MRC下的默认属性，这种属性的引用不会使对象的引用计数器增加，适用于非OC对象，即基本数据类型（int，float...），如果用于对象，当对象释放时，我们需要手动将assign置为nil,否则引用将变为野指针。

### ARC

+ strong : ARC下的默认属性，参考retain, strong拥有与retain几乎同样的特性，区别尚且不清楚。

+ weak : 弱引用，参考assign，唯一的不同之处是weak所指向的对象在释放时，weak会自动置nil，不必担心野指针的问题。

+ copy : 复制，这种属性的引用面对不同的对象，特性会稍有不同，当引用不可变对象时（NSString，NSArray..），它与strong并没有差异，但当引用可变对象时（NSMutableString，NSMutableArray..），它将开辟一块新的内存空间，建立一个新对象，并将源对象的内容复制过来，这个过程叫深拷贝，相对的，面对不可变对象，它执行的操作叫浅拷贝。copy修饰的变量可以保证自己不会影响任何其他变量。这里要注意的一点是，被copy修饰的变量在深拷贝时获取的依旧是一个不可变对象，因此永远不要用copy修饰可变对象，这会引发程序崩溃。

### 其他的属性修饰符

+ nonatomic/atomic : 原子性为默认属性，这种属性引用的对象在进行读写操作时只能同时被一个线程访问，保证了读写的线程安全，但将会降低程序的速度。而非原子性则允许多个线程同时读写，速度较快，但线程之间的操作可能会相互影响。

+ readwrite/readonly : 可读写属性为默认属性，只读属性修饰对象时，对象将不会自动生成setter方法，但在accessInstanceVariablesDirectly返回YES时，依然可以用KVC的方式修改实例的属性。


## 本篇到此为止，希望这对你有帮助，如果有错误或是有需要补充的地方，望告知。


